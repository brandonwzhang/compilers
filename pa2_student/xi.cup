
package com.bwz6jk2227esl89ahj34;

terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal String CHARACTER_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, BREAK, RETURN, USE, LENGTH, PLUS, MINUS, TIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, HIGH_MULT, UMINUS;

nonterminal program;

nonterminal empty;
nonterminal use_block;

nonterminal Integer oExpr; //expression involving arithmetic operators  
nonterminal Boolean bExpr; //expression involing boolean operators
nonterminal String array_index; //expression involving array[index] 
nonterminal String array_literal;

nonterminal expression; 
nonterminal expression_list; 
nonterminal expression_list_trailing_comma; 

nonterminal String basic_type;
nonterminal String type;
nonterminal String types;
nonterminal String array_sized;
nonterminal String array_empty;

nonterminal String typed_declaration; //TODO: chang to typed_declaration 
nonterminal String typed_declaration_list;
nonterminal String function_call;
nonterminal String assignment_lhs;
nonterminal String assignment_lhs_list;
nonterminal String assignment; 

nonterminal String if_statement;
nonterminal String while_statement;
nonterminal String return_statement; 
nonterminal String block; 
nonterminal String blocks; 
nonterminal String statement;
nonterminal String statement_no_semicolon;


nonterminal String function_declaration;
nonterminal String function_declarations;
nonterminal String function_block; 
nonterminal String function_body;

precedence nonassoc ELSE; 

precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL; 
precedence left LT, LEQ, GEQ, GT; 
precedence left PLUS, MINUS;
precedence left TIMES, HIGH_MULT, DIVIDE, MODULO;
precedence left UMINUS, NOT;

start with program;

empty ::= ;

oExpr ::= expression:e1 PLUS expression:e2	
		| expression:e1 MINUS expression:e2	
		| expression:e1 TIMES expression:e2	
		| expression:e1 DIVIDE expression:e2 	
		| expression:e1 MODULO expression:e2 	
		| expression:e1 HIGH_MULT expression:e2
		| MINUS expression:e %prec UMINUS	
		| OPEN_PAREN expression:e CLOSE_PAREN 	
		| INTEGER_LITERAL:n 		
		; 

bExpr ::= expression:e1 AND expression:e2
		| expression:e1 OR expression:e2
    	| expression:e1 EQUAL expression:e2
    	| expression:e1 NOT_EQUAL expression:e2
    	| expression:e1 LT expression:e2
    	| expression:e1 LEQ expression:e2
    	| expression:e1 GT expression:e2
    	| expression:e1 GEQ expression:e2
    	| NOT expression:e
    	| TRUE 
    	| FALSE
    	;

array_index ::= expression OPEN_BRACKET expression CLOSE_BRACKET; 

expression ::= IDENTIFIER 
  			 | STRING_LITERAL 
             | CHARACTER_LITERAL 
             | oExpr 
             | bExpr 
             | array_index 
             | function_call
             | array_literal; 
 
expression_list ::= expression COMMA expression_list 
				  | expression
				  ;

expression_list_trailing_comma ::= expression COMMA expression_list_trailing_comma 
								 | expression COMMA
								 ;
 

array_literal ::= OPEN_BRACE expression_list CLOSE_BRACE 
           |  OPEN_BRACE expression_list_trailing_comma CLOSE_BRACE
           ;

basic_type ::= INT 
            | BOOL 
            ; 
array_sized ::= OPEN_BRACKET expression CLOSE_BRACKET array_sized 
             | array_empty  
             ;
array_empty ::= OPEN_BRACKET CLOSE_BRACKET array_empty 
			 | empty  
             ;
type ::= basic_type array_sized; // does not allow [] after [n]  

types ::= type COMMA types 
		   | type
		   ; // for functions that return multiple results

typed_declaration ::= IDENTIFIER COLON type; //x:int

typed_declaration_list ::= typed_declaration COMMA typed_declaration_list 
						| typed_declaration;

function_call ::= IDENTIFIER OPEN_PAREN expression_list CLOSE_PAREN //f(x,y,z,...) 
				| IDENTIFIER OPEN_PAREN CLOSE_PAREN // f()
                | LENGTH OPEN_PAREN expression CLOSE_PAREN
                ;

assignment_lhs ::= IDENTIFIER 
                 | typed_declaration 
                 | UNDERSCORE 
                 ;
                 
assignment_lhs_list ::= assignment_lhs COMMA assignment_lhs_list 
					  | assignment_lhs
                      ;

assignment ::= assignment_lhs GETS expression 
			 | assignment_lhs_list GETS function_call; 

if_statement ::= IF OPEN_PAREN expression CLOSE_PAREN block
               | IF OPEN_PAREN expression CLOSE_PAREN block ELSE block
               ;

while_statement ::= WHILE OPEN_PAREN expression CLOSE_PAREN block;

return_statement ::= RETURN expression_list 
                   | RETURN 
                   ;

statement_no_semicolon ::= if_statement 
             			 | while_statement 
                         | typed_declaration_list 
                         | assignment
                         ; 

statement ::= statement_no_semicolon 
			| statement_no_semicolon SEMICOLON
			;

function_block ::= OPEN_BRACE blocks return_statement CLOSE_BRACE;

block ::= OPEN_BRACE blocks CLOSE_BRACE 
		| function_block
        | statement
        ;

blocks ::= block blocks
		 | empty
         ;

function_declaration ::= IDENTIFIER OPEN_PAREN typed_declaration_list CLOSE_PAREN COLON types function_body
                       | IDENTIFIER OPEN_PAREN typed_declaration_list CLOSE_PAREN function_body
                       ;

function_declarations ::= function_declaration function_declarations 
						| empty;


use_block ::= USE IDENTIFIER use_block 
			| empty;

program ::= use_block function_declarations;
