// TODO: Style!!!!!! https://www.lysator.liu.se/c/ANSI-C-grammar-y.html

package com.bwz6jk2227esl89ahj34;

// You might want to add types to these declarations.
terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal String CHARACTER_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, BREAK, RETURN, USE, LENGTH, PLUS, MINUS, TIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, HIGH_MULT, UMINUS;

// You might want to add types to these declarations.
nonterminal program;
// Add more nonterminals here...

// TODO: change everything away from camelcase & check the nonterminal types lol
nonterminal empty;
nonterminal use_block;

nonterminal Integer oExpr; //expression involving arithmetic operators  
nonterminal Boolean bExpr; //expression involing boolean operators
nonterminal String arrayIndex; //expression involving array[index] 
nonterminal String arrayObj;

nonterminal expression; 
nonterminal expression_list; 
nonterminal expression_list_trailing_comma; 

nonterminal String basicType;
nonterminal String varType;
nonterminal String varTypes;
nonterminal String arraySized;
nonterminal String arrayEmpty;

nonterminal String type_declaration;
nonterminal String type_declarations;
nonterminal String type_declaration_list;
nonterminal String function_call;
nonterminal String assignment_lhs;
nonterminal String assignment_lhs_list;
nonterminal String assignment; 

nonterminal String if_statement;
nonterminal String while_statement;
nonterminal String return_statement; 
nonterminal String procedure_call;
nonterminal String block; 
nonterminal String blocks; 
nonterminal String statement;
nonterminal String statement_no_semicolon;


nonterminal String function_declaration;
nonterminal String function_declarations;
nonterminal String function_block; 
nonterminal String function_body;

precedence nonassoc ELSE; 

precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL; 
precedence left LT, LEQ, GEQ, GT; 
precedence left PLUS, MINUS;
precedence left TIMES, HIGH_MULT, DIVIDE, MODULO;
precedence left UMINUS, NOT;

start with program;

empty ::= ;

oExpr ::= oExpr:e1 PLUS oExpr:e2	
		| oExpr:e1 MINUS oExpr:e2	
		| oExpr:e1 TIMES oExpr:e2	
		| oExpr:e1 DIVIDE oExpr:e2 	
		| oExpr:e1 MODULO oExpr:e2 	
		| oExpr:e1 HIGH_MULT oExpr:e2
		| MINUS oExpr:e %prec UMINUS	
		| OPEN_PAREN oExpr:e CLOSE_PAREN 	
		| INTEGER_LITERAL:n 		
		; 

bExpr ::= bExpr:e1 AND bExpr:e2
		| bExpr:e1 OR bExpr:e2
    	| bExpr:e1 EQUAL bExpr:e2
    	| bExpr:e1 NOT_EQUAL bExpr:e2
    	| bExpr:e1 LT bExpr:e2
    	| bExpr:e1 LEQ bExpr:e2
    	| bExpr:e1 GT bExpr:e2
    	| bExpr:e1 GEQ bExpr:e2
    	| NOT bExpr:e
    	| TRUE 
    	| FALSE
    	;

arrayIndex ::= IDENTIFIER OPEN_BRACKET expression CLOSE_BRACKET; //arr[1] arr[f(x)] TODO @223  

expression ::= IDENTIFIER 
  			 | STRING_LITERAL 
             | CHARACTER_LITERAL 
             | oExpr 
             | bExpr 
             | arrayIndex 
             | function_call
             | arrayObj; 
 
expression_list ::= expression COMMA expression_list 
				  | expression
				  ;

expression_list_trailing_comma ::= expression COMMA expression_list_trailing_comma 
								 | expression COMMA
								 ;
 

arrayObj ::= OPEN_BRACE expression_list CLOSE_BRACE 
           |  OPEN_BRACE expression_list_trailing_comma CLOSE_BRACE
           ;

basicType ::= INT 
            | BOOL 
            ; 
arraySized ::= OPEN_BRACKET expression CLOSE_BRACKET arraySized 
             | arrayEmpty  
             ;
arrayEmpty ::= OPEN_BRACKET CLOSE_BRACKET arrayEmpty 
			 | empty  
             ;
varType ::= basicType arraySized; // does not allow [] after [n]  

varTypes ::= varType COMMA varTypes 
		   | varType
		   ; // for functions that return multiple results

type_declaration ::= IDENTIFIER COLON varType; //x:int

type_declaration_list ::= type_declaration COMMA type_declaration_list 
						| type_declaration;

function_call ::= IDENTIFIER OPEN_PAREN expression_list CLOSE_PAREN //f(x,y,z,...) 
				| IDENTIFIER OPEN_PAREN CLOSE_PAREN // f()
                | LENGTH OPEN_PAREN expression CLOSE_PAREN
                ;

assignment_lhs ::= IDENTIFIER 
                 | type_declaration 
                 | UNDERSCORE 
                 ;
                 
assignment_lhs_list ::= assignment_lhs COMMA assignment_lhs_list 
					  | assignment_lhs
                      ;

assignment ::= assignment_lhs GETS expression 
			 | assignment_lhs_list GETS function_call; 

if_statement ::= IF OPEN_PAREN expression CLOSE_PAREN block
               | IF OPEN_PAREN expression CLOSE_PAREN block ELSE block
               ;

while_statement ::= WHILE OPEN_PAREN expression CLOSE_PAREN block;

return_statement ::= RETURN expression_list 
                   | RETURN 
                   ;

statement_no_semicolon ::= if_statement 
             			 | while_statement 
                         | procedure_call 
                         | type_declaration_list 
                         | assignment
                         ; 

statement ::= statement_no_semicolon 
			| statement_no_semicolon SEMICOLON
			;

function_block ::= OPEN_BRACE blocks return_statement CLOSE_BRACE;

block ::= OPEN_BRACE blocks CLOSE_BRACE 
		| function_block
        | statement
        ;

blocks ::= block blocks
		 | empty
         ;

function_declaration ::= IDENTIFIER OPEN_PAREN type_declaration_list CLOSE_PAREN COLON varTypes function_body
                       | IDENTIFIER OPEN_PAREN type_declaration_list CLOSE_PAREN function_body
                       ;

function_declarations ::= function_declaration function_declarations 
						| empty;


use_block ::= USE IDENTIFIER use_block 
			| empty;

program ::= use_block function_declarations;
