
package com.bwz6jk2227esl89ahj34;

terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal String CHARACTER_LITERAL;
terminal Integer INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, BREAK, RETURN, USE, LENGTH, PLUS, MINUS, TIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, HIGH_MULT, UMINUS;

nonterminal program;

nonterminal empty;
nonterminal use_block;

nonterminal String binary_operator; 
nonterminal String unary_operator; 
nonterminal String binary_operator_expression;
nonterminal String unary_operator_expression; 

nonterminal String boolean_literal; 
nonterminal String array_index; //expression involving array[index] 
nonterminal String array_literal;

nonterminal expression; 
nonterminal expression_list; 
nonterminal expression_list_trailing_comma; 

nonterminal String basic_type;
nonterminal String type;
nonterminal String types;
nonterminal String array_sized;
nonterminal String array_empty;

nonterminal String typed_declaration; 
nonterminal String typed_declaration_list;
nonterminal String function_call;
nonterminal String assignment_lhs;
nonterminal String assignment_lhs_list;
nonterminal String assignment; 

nonterminal String if_statement;
nonterminal String while_statement;
nonterminal String return_statement; 
nonterminal String block; 
nonterminal String blocks; 
nonterminal String statement;
nonterminal String statement_no_semicolon;


nonterminal String function_declaration;
nonterminal String function_declarations;
nonterminal String function_block; 
nonterminal String function_body;

nonterminal String procedure_call;

precedence nonassoc ELSE; 

precedence left OR;
precedence left AND;
precedence left EQUAL, NOT_EQUAL; 
precedence left LT, LEQ, GEQ, GT; 
precedence left PLUS, MINUS;
precedence left TIMES, HIGH_MULT, DIVIDE, MODULO;
precedence left UMINUS, NOT;
precedence left OPEN_BRACKET; 

start with program;

empty ::= ;

boolean_literal ::= TRUE 
				  | FALSE
				  ;  

binary_operator ::= PLUS
				  | MINUS
				  | TIMES
				  | DIVIDE
				  | MODULO
				  | HIGH_MULT
				  | AND
				  | OR 
				  | EQUAL
				  | NOT_EQUAL
				  | LT
				  | LEQ 
				  | GT 
				  | GEQ 
				  ;

unary_operator ::= NOT 
				 | MINUS 
				 ;

binary_operator_expression ::= expression:e1 binary_operator expression:e2;

unary_operator_expression ::= NOT expression:e
							| MINUS expression:e %prec UMINUS 
							;


array_index ::= expression OPEN_BRACKET expression CLOSE_BRACKET;  

expression ::= IDENTIFIER 
  			 | STRING_LITERAL 
             | CHARACTER_LITERAL 
             | array_index 
             | function_call
             | array_literal 
             | boolean_literal 
             | INTEGER_LITERAL 
             | binary_operator_expression
             | unary_operator_expression
             ; 
 
expression_list ::= expression COMMA expression_list 
				  | expression
				  ;

expression_list_trailing_comma ::= expression COMMA expression_list_trailing_comma 
								 | expression COMMA
								 ;
 

array_literal ::= OPEN_BRACE expression_list CLOSE_BRACE 
           |  OPEN_BRACE expression_list_trailing_comma CLOSE_BRACE
           ;

basic_type ::= INT 
            | BOOL 
            ; 

array_sized ::= OPEN_BRACKET expression CLOSE_BRACKET array_sized 
             | array_empty  
             ;
array_empty ::= OPEN_BRACKET CLOSE_BRACKET array_empty 
			 | empty  
             ;
type ::= basic_type array_sized; // does not allow [] after [n]  

types ::= type COMMA types 
		   | type
		   ; // for functions that return multiple results

typed_declaration ::= IDENTIFIER COLON type; //x:int

typed_declaration_list ::= typed_declaration COMMA typed_declaration_list 
						| typed_declaration;

function_call ::= IDENTIFIER OPEN_PAREN expression_list CLOSE_PAREN //f(x,y,z,...) 
				| IDENTIFIER OPEN_PAREN CLOSE_PAREN // f()
                | LENGTH OPEN_PAREN expression CLOSE_PAREN
                ;

assignment_lhs ::= IDENTIFIER 
                 | typed_declaration 
                 | UNDERSCORE 
                 ;
                 
assignment_lhs_list ::= assignment_lhs COMMA assignment_lhs_list 
					  | assignment_lhs
                      ;

assignment ::= assignment_lhs GETS expression 
			 | assignment_lhs_list GETS function_call; 

if_statement ::= IF OPEN_PAREN expression CLOSE_PAREN block
               | IF OPEN_PAREN expression CLOSE_PAREN block ELSE block
               ;

while_statement ::= WHILE OPEN_PAREN expression CLOSE_PAREN block;

return_statement ::= RETURN expression_list 
                   | RETURN 
                   ;

statement_no_semicolon ::= if_statement 
             			 | while_statement 
             			 | procedure_call
                         | typed_declaration_list 
                         | assignment
                         ; 

statement ::= statement_no_semicolon 
			| statement_no_semicolon SEMICOLON
			;

function_block ::= OPEN_BRACE blocks return_statement CLOSE_BRACE;

block ::= OPEN_BRACE blocks CLOSE_BRACE 
		| function_block
        | statement
        ;

blocks ::= block blocks
		 | empty
         ;

function_declaration ::= IDENTIFIER OPEN_PAREN typed_declaration_list CLOSE_PAREN COLON types function_body
                       | IDENTIFIER OPEN_PAREN typed_declaration_list CLOSE_PAREN function_body
                       ;

function_declarations ::= function_declaration function_declarations 
						| empty;

procedure_call ::= IDENTIFIER OPEN_PAREN expression_list CLOSE_PAREN //f(x,y,z,...) 
				| IDENTIFIER OPEN_PAREN CLOSE_PAREN // f()
				;

use_block ::= USE IDENTIFIER use_block 
			| empty;

program ::= use_block function_declarations;
