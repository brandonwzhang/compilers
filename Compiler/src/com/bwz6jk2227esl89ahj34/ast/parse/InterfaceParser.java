
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20150326
//----------------------------------------------------

package com.bwz6jk2227esl89ahj34.ast.parse;

import com.bwz6jk2227esl89ahj34.ast.*;
import com.bwz6jk2227esl89ahj34.ast.type.FunctionType;
import com.bwz6jk2227esl89ahj34.ast.Identifier;
import com.bwz6jk2227esl89ahj34.ast.type.IntType;
import com.bwz6jk2227esl89ahj34.ast.type.BoolType;
import com.bwz6jk2227esl89ahj34.ast.type.PrimitiveType;
import com.bwz6jk2227esl89ahj34.ast.type.VariableType;
import com.bwz6jk2227esl89ahj34.ast.type.VariableTypeList;
import com.bwz6jk2227esl89ahj34.ast.parse.Interface;
import com.bwz6jk2227esl89ahj34.util.Util;
import com.bwz6jk2227esl89ahj34.util.prettyprint.Pair;
import com.bwz6jk2227esl89ahj34.ast.type.*;
import java_cup.runtime.Symbol;
import java.io.FileReader;
import java.util.AbstractMap.SimpleEntry;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;

/** CUP v0.11b 20150326 generated parser.
  */
public class InterfaceParser
 extends java_cup.runtime.lr_parser {

  @Override
  public final Class<?> getSymbolContainer() {
    return ParserSym.class;
  }

  /** Default constructor. */
  @Deprecated
  public InterfaceParser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public InterfaceParser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner and a SymbolFactory. */
  public InterfaceParser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\041\000\002\002\004\000\002\002\002\000\002\003" +
    "\003\000\002\003\003\000\002\006\003\000\002\005\005" +
    "\000\002\005\003\000\002\004\004\000\002\004\004\000" +
    "\002\007\005\000\002\007\003\000\002\010\005\000\002" +
    "\011\005\000\002\011\003\000\002\012\003\000\002\012" +
    "\003\000\002\013\010\000\002\013\006\000\002\014\003" +
    "\000\002\014\004\000\002\015\004\000\002\015\003\000" +
    "\002\016\005\000\002\016\006\000\002\016\003\000\002" +
    "\017\007\000\002\017\011\000\002\017\006\000\002\017" +
    "\010\000\002\020\004\000\002\020\004\000\002\020\003" +
    "\000\002\021\004" });

  /** Access to production table. */
  @Override
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\074\000\012\002\000\004\000\021\005\056\000\001" +
    "\002\000\010\002\000\004\012\056\020\001\002\000\004" +
    "\004\012\001\002\000\004\002\010\001\002\000\010\002" +
    "\uffe9\004\uffe9\056\uffe9\001\002\000\004\002\001\001\002" +
    "\000\014\002\000\004\000\021\005\051\014\056\000\001" +
    "\002\000\034\002\ufffd\004\ufffd\021\ufffd\041\ufffd\043\ufffd" +
    "\044\ufffd\045\ufffd\046\ufffd\047\ufffd\050\ufffd\051\ufffd\056" +
    "\ufffd\057\ufffd\001\002\000\010\002\uffeb\004\uffeb\056\uffeb" +
    "\001\002\000\012\002\000\004\000\021\005\056\000\001" +
    "\002\000\010\002\uffea\004\uffea\056\uffea\001\002\000\004" +
    "\043\045\001\002\000\004\002\uffe1\001\002\000\004\004" +
    "\012\001\002\000\010\002\000\004\012\056\020\001\002" +
    "\000\010\002\000\004\012\056\020\001\002\000\014\002" +
    "\uffef\004\uffef\046\uffef\051\025\056\uffef\001\002\000\004" +
    "\002\uffe2\001\002\000\012\002\uffee\004\uffee\046\uffee\056" +
    "\uffee\001\002\000\004\002\uffe3\001\002\000\004\002\uffe4" +
    "\001\002\000\006\045\032\057\031\001\002\000\004\004" +
    "\012\001\002\000\006\004\012\046\034\001\002\000\004" +
    "\046\037\001\002\000\010\002\uffe6\004\uffe6\056\uffe6\001" +
    "\002\000\006\004\012\046\uffec\001\002\000\004\046\uffed" +
    "\001\002\000\010\002\uffe8\004\uffe8\056\uffe8\001\002\000" +
    "\004\045\041\001\002\000\006\004\012\046\043\001\002" +
    "\000\004\046\044\001\002\000\010\002\uffe5\004\uffe5\056" +
    "\uffe5\001\002\000\010\002\uffe7\004\uffe7\056\uffe7\001\002" +
    "\000\006\004\012\044\000\001\002\000\004\047\075\001" +
    "\002\000\004\044\055\001\002\000\004\044\ufff3\001\002" +
    "\000\006\044\ufff4\050\053\001\002\000\004\044\ufff2\001" +
    "\002\000\004\004\012\001\002\000\004\044\ufff5\001\002" +
    "\000\016\002\ufff0\004\ufff0\046\ufff0\047\056\051\ufff0\056" +
    "\ufff0\001\002\000\010\004\012\012\064\013\062\001\002" +
    "\000\022\002\000\004\000\041\066\044\000\046\000\050" +
    "\000\051\000\056\000\001\002\000\016\002\ufff7\004\ufff7" +
    "\046\ufff7\050\072\051\ufff7\056\ufff7\001\002\000\014\002" +
    "\ufff1\004\ufff1\046\ufff1\051\ufff1\056\ufff1\001\002\000\022" +
    "\002\ufffe\004\ufffe\041\ufffe\044\ufffe\046\ufffe\050\ufffe\051" +
    "\ufffe\056\ufffe\001\002\000\022\002\000\004\000\041\066" +
    "\044\000\046\000\050\000\051\000\056\000\001\002\000" +
    "\022\002\uffff\004\uffff\041\uffff\044\uffff\046\uffff\050\uffff" +
    "\051\uffff\056\uffff\001\002\000\020\002\ufffa\004\ufffa\044" +
    "\ufffa\046\ufffa\050\ufffa\051\ufffa\056\ufffa\001\002\000\004" +
    "\042\070\001\002\000\020\002\ufffb\004\ufffb\044\ufffb\046" +
    "\ufffb\050\ufffb\051\ufffb\056\ufffb\001\002\000\022\002\000" +
    "\004\000\041\066\044\000\046\000\050\000\051\000\056" +
    "\000\001\002\000\020\002\ufffc\004\ufffc\044\ufffc\046\ufffc" +
    "\050\ufffc\051\ufffc\056\ufffc\001\002\000\010\004\012\012" +
    "\064\013\062\001\002\000\014\002\ufff8\004\ufff8\046\ufff8" +
    "\051\ufff8\056\ufff8\001\002\000\020\002\ufff9\004\ufff9\044" +
    "\ufff9\046\ufff9\050\ufff9\051\ufff9\056\ufff9\001\002\000\010" +
    "\004\012\012\064\013\062\001\002\000\006\044\ufff6\050" +
    "\ufff6\001\002" });

  /** Access to parse-action table. */
  @Override
  public short[][] action_table() {return _action_table;}

  /** {@code reduce_goto} table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\074\000\010\002\006\016\003\021\005\001\001\000" +
    "\016\002\023\006\015\013\022\014\020\017\021\020\016" +
    "\001\001\000\004\006\010\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\002\006\016\012" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\002" +
    "\006\016\014\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\006\027\001\001\000\016\002" +
    "\023\006\015\013\022\014\020\017\021\020\026\001\001" +
    "\000\016\002\023\006\015\013\022\014\020\017\021\020" +
    "\025\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\006\037\001\001\000\012\006\015\013\022" +
    "\014\034\015\032\001\001\000\002\001\001\000\002\001" +
    "\001\000\012\006\015\013\022\014\034\015\035\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\006\015\013\022\014\034\015\041\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\002" +
    "\051\006\045\010\050\011\047\012\046\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\006\045\010\050\011\053" +
    "\001\001\000\002\001\001\000\002\001\001\000\012\003" +
    "\062\004\057\006\056\007\060\001\001\000\006\002\066" +
    "\005\073\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\002\066\005\064\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\002\066\005\070\001\001\000\002\001\001" +
    "\000\012\003\062\004\057\006\056\007\072\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\003\062\004\075" +
    "\006\056\001\001\000\002\001\001" });

  /** Access to {@code reduce_goto} table. */
  @Override
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$InterfaceParser$actions action_obj;

  /** Action encapsulation object initializer. */
  @Override
  protected void init_actions()
    {
      action_obj = new CUP$InterfaceParser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  @Override
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack<java_cup.runtime.Symbol> stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$InterfaceParser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  @Override
  public int start_state() {return 0;}
  /** Indicates start production. */
  @Override
  public int start_production() {return 0;}

  /** {@code EOF} Symbol index. */
  @Override
  public int EOF_sym() {return 0;}

  /** {@code error} Symbol index. */
  @Override
  public int error_sym() {return 1;}




    /**
     * Parses an interface file and adds the declarations to a given list
     * @param libPath       a String of the path to the interface files
     * @param interfaceName a String of the name of the interface
     * @param inter A reference to an interface that gets set by this function 
     * @return              a String of the error or null if no error
     */
    public static String parseInterface(String libPath, String interfaceName, Interface inter) {
        try {
            FileReader reader = new FileReader(libPath + interfaceName + ".ixi");
            Lexer lexer = new Lexer(reader);
            InterfaceParser parser = new InterfaceParser(lexer);
            Symbol result = parser.parse();
            if (parser.hasSyntaxError) {
                // Encountered parsing error, return error message
                return parser.syntaxErrMessage;
            }
            inter.set((Interface) result.value); 
        } catch(Exception e) {
            return "Interface " + interfaceName + " not found";
        }
        return null;
    }

    public boolean hasSyntaxError = false;
    public String syntaxErrMessage = "";

    public void syntax_error(java_cup.runtime.Symbol cur_token){
        hasSyntaxError = true;
        syntaxErrMessage = cur_token.left + ":" + cur_token.right +
          " error: Unexpected token " + Util.symbolTranslation.get(cur_token.sym);
        if (cur_token.value != null) {
            syntaxErrMessage += " " + cur_token.value;
        }
        done_parsing();
    }


/** Cup generated class to encapsulate user supplied action code.*/
class CUP$InterfaceParser$actions {
    private final InterfaceParser parser;

    /** Constructor */
    CUP$InterfaceParser$actions(InterfaceParser parser) {
        this.parser = parser;
    }

    /** Method with the actual generated action code for actions 0 to 32. */
    public final java_cup.runtime.Symbol CUP$InterfaceParser$do_action_part00000000(
            int                        CUP$InterfaceParser$act_num,
            java_cup.runtime.lr_parser CUP$InterfaceParser$parser,
            java.util.Stack<java_cup.runtime.Symbol> CUP$InterfaceParser$stack,
            int                        CUP$InterfaceParser$top)
            throws java.lang.Exception {
            /* Symbol object for return from actions */
            java_cup.runtime.Symbol CUP$InterfaceParser$result;

        /* select the action based on the action number */
        switch (CUP$InterfaceParser$act_num) {
        /*. . . . . . . . . . . . . . . . . . . .*/
        case 0: // $START ::= interface EOF 
            {
                Object RESULT = null;
                int start_valleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int start_valright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                Interface start_val = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<Interface> value();
                RESULT = start_val;
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("$START",0, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            /* ACCEPT */
            CUP$InterfaceParser$parser.done_parsing();
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 1: // empty ::= 
            {
                Object RESULT = null;

                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("empty",0, CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 2: // primitive_type ::= INT 
            {
                PrimitiveType RESULT = null;
                 RESULT = new IntType(); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("primitive_type",1, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 3: // primitive_type ::= BOOL 
            {
                PrimitiveType RESULT = null;
                 RESULT = new BoolType(); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("primitive_type",1, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 4: // identifier ::= IDENTIFIER 
            {
                Identifier RESULT = null;
                int idleft = CUP$InterfaceParser$stack.peek().left;
                int idright = CUP$InterfaceParser$stack.peek().right;
                String id = CUP$InterfaceParser$stack.peek().<String> value();
                 RESULT = new Identifier(id); RESULT.setLocation(parser.stack.peek()); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("identifier",4, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 5: // array_no_size_type ::= OPEN_BRACKET CLOSE_BRACKET array_no_size_type 
            {
                Integer RESULT = null;
                int anstleft = CUP$InterfaceParser$stack.peek().left;
                int anstright = CUP$InterfaceParser$stack.peek().right;
                Integer anst = CUP$InterfaceParser$stack.peek().<Integer> value();
                 RESULT = anst + 1; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("array_no_size_type",3, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 6: // array_no_size_type ::= empty 
            {
                Integer RESULT = null;
                 RESULT = 0; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("array_no_size_type",3, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 7: // var_type ::= primitive_type array_no_size_type 
            {
                VariableType RESULT = null;
                int ptleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int ptright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                PrimitiveType pt = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<PrimitiveType> value();
                int anstleft = CUP$InterfaceParser$stack.peek().left;
                int anstright = CUP$InterfaceParser$stack.peek().right;
                Integer anst = CUP$InterfaceParser$stack.peek().<Integer> value();
                 RESULT = VariableType.construct(pt, anst); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("var_type",2, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 8: // var_type ::= identifier array_no_size_type 
            {
                VariableType RESULT = null;
                int class_nameleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int class_nameright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                Identifier class_name = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<Identifier> value();
                int anstleft = CUP$InterfaceParser$stack.peek().left;
                int anstright = CUP$InterfaceParser$stack.peek().right;
                Integer anst = CUP$InterfaceParser$stack.peek().<Integer> value();
                 RESULT = VariableType.construct(new ClassType(class_name), anst); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("var_type",2, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 9: // function_declaration_return_types ::= var_type COMMA function_declaration_return_types 
            {
                List<VariableType> RESULT = null;
                int tleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).left;
                int tright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).right;
                VariableType t = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).<VariableType> value();
                int lstleft = CUP$InterfaceParser$stack.peek().left;
                int lstright = CUP$InterfaceParser$stack.peek().right;
                List<VariableType> lst = CUP$InterfaceParser$stack.peek().<List<VariableType>> value();
                 lst.add(0,t); RESULT = lst; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration_return_types",5, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 10: // function_declaration_return_types ::= var_type 
            {
                List<VariableType> RESULT = null;
                int tleft = CUP$InterfaceParser$stack.peek().left;
                int tright = CUP$InterfaceParser$stack.peek().right;
                VariableType t = CUP$InterfaceParser$stack.peek().<VariableType> value();
                 List<VariableType> lst = new LinkedList<>(); lst.add(0, t); RESULT = lst; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration_return_types",5, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 11: // function_declaration_argument_single ::= identifier COLON var_type 
            {
                SimpleEntry<Identifier,VariableType> RESULT = null;
                int ileft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).left;
                int iright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).right;
                Identifier i = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).<Identifier> value();
                int tleft = CUP$InterfaceParser$stack.peek().left;
                int tright = CUP$InterfaceParser$stack.peek().right;
                VariableType t = CUP$InterfaceParser$stack.peek().<VariableType> value();
                 RESULT = new SimpleEntry<Identifier, VariableType>(i, t); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration_argument_single",6, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 12: // function_declaration_argument_list ::= function_declaration_argument_single COMMA function_declaration_argument_list 
            {
                List<SimpleEntry<Identifier,VariableType>> RESULT = null;
                int fdasleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).left;
                int fdasright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).right;
                SimpleEntry<Identifier,VariableType> fdas = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).<SimpleEntry<Identifier,VariableType>> value();
                int lstleft = CUP$InterfaceParser$stack.peek().left;
                int lstright = CUP$InterfaceParser$stack.peek().right;
                List<SimpleEntry<Identifier,VariableType>> lst = CUP$InterfaceParser$stack.peek().<List<SimpleEntry<Identifier,VariableType>>> value();
                 lst.add(0, fdas); RESULT = lst; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration_argument_list",7, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 13: // function_declaration_argument_list ::= function_declaration_argument_single 
            {
                List<SimpleEntry<Identifier,VariableType>> RESULT = null;
                int fdasleft = CUP$InterfaceParser$stack.peek().left;
                int fdasright = CUP$InterfaceParser$stack.peek().right;
                SimpleEntry<Identifier,VariableType> fdas = CUP$InterfaceParser$stack.peek().<SimpleEntry<Identifier,VariableType>> value();
                 List<SimpleEntry<Identifier, VariableType>> lst = new LinkedList<>(); lst.add(0, fdas); RESULT = lst; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration_argument_list",7, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 14: // function_declaration_argument ::= function_declaration_argument_list 
            {
                List<SimpleEntry<Identifier,VariableType>> RESULT = null;
                int lstleft = CUP$InterfaceParser$stack.peek().left;
                int lstright = CUP$InterfaceParser$stack.peek().right;
                List<SimpleEntry<Identifier,VariableType>> lst = CUP$InterfaceParser$stack.peek().<List<SimpleEntry<Identifier,VariableType>>> value();
                 RESULT = lst; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration_argument",8, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 15: // function_declaration_argument ::= empty 
            {
                List<SimpleEntry<Identifier,VariableType>> RESULT = null;
                 RESULT = new LinkedList<>(); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration_argument",8, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 16: // function_declaration ::= identifier OPEN_PAREN function_declaration_argument CLOSE_PAREN COLON function_declaration_return_types 
            {
                FunctionDeclaration RESULT = null;
                int idleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-5).left;
                int idright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-5).right;
                Identifier id = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-5).<Identifier> value();
                int argPairsleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).left;
                int argPairsright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).right;
                List<SimpleEntry<Identifier,VariableType>> argPairs = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).<List<SimpleEntry<Identifier,VariableType>>> value();
                int tleft = CUP$InterfaceParser$stack.peek().left;
                int tright = CUP$InterfaceParser$stack.peek().right;
                List<VariableType> t = CUP$InterfaceParser$stack.peek().<List<VariableType>> value();
                 List<Identifier> args = new LinkedList<>(); List<VariableType> argTypes = new LinkedList<>(); for (SimpleEntry<Identifier, VariableType> se : argPairs) { args.add(se.getKey()); argTypes.add(se.getValue()); } RESULT = new FunctionDeclaration(id, new FunctionType(argTypes, new VariableTypeList(t)), args, null); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration",9, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-5), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 17: // function_declaration ::= identifier OPEN_PAREN function_declaration_argument CLOSE_PAREN 
            {
                FunctionDeclaration RESULT = null;
                int idleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).left;
                int idright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).right;
                Identifier id = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).<Identifier> value();
                int argPairsleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int argPairsright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                List<SimpleEntry<Identifier,VariableType>> argPairs = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<List<SimpleEntry<Identifier,VariableType>>> value();
                 List<Identifier> args = new LinkedList<>(); List<VariableType> argTypes = new LinkedList<>(); for (SimpleEntry<Identifier, VariableType> se : argPairs) { args.add(se.getKey()); argTypes.add(se.getValue()); } RESULT = new FunctionDeclaration(id, new FunctionType(argTypes, new VariableTypeList(new LinkedList<>())), args, null); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration",9, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 18: // function_declaration_line ::= function_declaration 
            {
                FunctionDeclaration RESULT = null;
                int fdleft = CUP$InterfaceParser$stack.peek().left;
                int fdright = CUP$InterfaceParser$stack.peek().right;
                FunctionDeclaration fd = CUP$InterfaceParser$stack.peek().<FunctionDeclaration> value();
                 RESULT = fd; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration_line",10, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 19: // function_declaration_line ::= function_declaration SEMICOLON 
            {
                FunctionDeclaration RESULT = null;
                int fdleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int fdright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                FunctionDeclaration fd = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<FunctionDeclaration> value();
                 RESULT = fd; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration_line",10, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 20: // function_declaration_list ::= function_declaration_line function_declaration_list 
            {
                List<FunctionDeclaration> RESULT = null;
                int fdleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int fdright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                FunctionDeclaration fd = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<FunctionDeclaration> value();
                int lstleft = CUP$InterfaceParser$stack.peek().left;
                int lstright = CUP$InterfaceParser$stack.peek().right;
                List<FunctionDeclaration> lst = CUP$InterfaceParser$stack.peek().<List<FunctionDeclaration>> value();
                 lst.add(0, fd); RESULT = lst; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration_list",11, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 21: // function_declaration_list ::= function_declaration_line 
            {
                List<FunctionDeclaration> RESULT = null;
                int fdleft = CUP$InterfaceParser$stack.peek().left;
                int fdright = CUP$InterfaceParser$stack.peek().right;
                FunctionDeclaration fd = CUP$InterfaceParser$stack.peek().<FunctionDeclaration> value();
                 RESULT = new LinkedList<FunctionDeclaration>(); RESULT.add(fd); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("function_declaration_list",11, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 22: // use_block ::= USE identifier use_block 
            {
                List<UseStatement> RESULT = null;
                int idleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int idright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                Identifier id = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<Identifier> value();
                int uleft = CUP$InterfaceParser$stack.peek().left;
                int uright = CUP$InterfaceParser$stack.peek().right;
                List<UseStatement> u = CUP$InterfaceParser$stack.peek().<List<UseStatement>> value();
                 u.add(0, new UseStatement(id)); RESULT = u; RESULT.get(0).setLocation(id); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("use_block",12, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 23: // use_block ::= USE identifier SEMICOLON use_block 
            {
                List<UseStatement> RESULT = null;
                int idleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).left;
                int idright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).right;
                Identifier id = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).<Identifier> value();
                int uleft = CUP$InterfaceParser$stack.peek().left;
                int uright = CUP$InterfaceParser$stack.peek().right;
                List<UseStatement> u = CUP$InterfaceParser$stack.peek().<List<UseStatement>> value();
                 u.add(0, new UseStatement(id)); RESULT = u; RESULT.get(0).setLocation(id); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("use_block",12, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 24: // use_block ::= empty 
            {
                List<UseStatement> RESULT = null;
                 RESULT = new LinkedList<UseStatement>(); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("use_block",12, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 25: // class_declaration ::= CLASS identifier OPEN_BRACE function_declaration_list CLOSE_BRACE 
            {
                ClassDeclaration RESULT = null;
                int idleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).left;
                int idright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).right;
                Identifier id = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).<Identifier> value();
                int bodyleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int bodyright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                List<FunctionDeclaration> body = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<List<FunctionDeclaration>> value();
                 List<MethodDeclaration> methods = new LinkedList<>(); for(FunctionDeclaration fd : body) { methods.add(new MethodDeclaration(id, fd)); } RESULT = new ClassDeclaration(id, new LinkedList<TypedDeclaration>(), methods, Optional.empty()); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("class_declaration",13, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-4), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 26: // class_declaration ::= CLASS identifier EXTENDS identifier OPEN_BRACE function_declaration_list CLOSE_BRACE 
            {
                ClassDeclaration RESULT = null;
                int idleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-5).left;
                int idright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-5).right;
                Identifier id = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-5).<Identifier> value();
                int id2left = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).left;
                int id2right = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).right;
                Identifier id2 = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3).<Identifier> value();
                int bodyleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int bodyright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                List<FunctionDeclaration> body = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<List<FunctionDeclaration>> value();
                 List<MethodDeclaration> methods = new LinkedList<>(); for(FunctionDeclaration fd : body) { methods.add(new MethodDeclaration(id, fd)); } RESULT = new ClassDeclaration(id, new LinkedList<TypedDeclaration>(), methods, Optional.of(id2)); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("class_declaration",13, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-6), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 27: // class_declaration ::= CLASS identifier OPEN_BRACE CLOSE_BRACE 
            {
                ClassDeclaration RESULT = null;
                int idleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).left;
                int idright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).right;
                Identifier id = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).<Identifier> value();
                 List<MethodDeclaration> methods = new LinkedList<>(); RESULT = new ClassDeclaration(id, new LinkedList<TypedDeclaration>(), methods, Optional.empty()); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("class_declaration",13, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-3), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 28: // class_declaration ::= CLASS identifier EXTENDS identifier OPEN_BRACE CLOSE_BRACE 
            {
                ClassDeclaration RESULT = null;
                int idleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-4).left;
                int idright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-4).right;
                Identifier id = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-4).<Identifier> value();
                int id2left = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).left;
                int id2right = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).right;
                Identifier id2 = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-2).<Identifier> value();
                 List<MethodDeclaration> methods = new LinkedList<>(); RESULT = new ClassDeclaration(id, new LinkedList<TypedDeclaration>(), methods, Optional.of(id2)); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("class_declaration",13, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-5), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 29: // interface_body ::= function_declaration_line interface_body 
            {
                Pair<List<FunctionDeclaration>,List<ClassDeclaration>> RESULT = null;
                int fdleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int fdright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                FunctionDeclaration fd = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<FunctionDeclaration> value();
                int pleft = CUP$InterfaceParser$stack.peek().left;
                int pright = CUP$InterfaceParser$stack.peek().right;
                Pair<List<FunctionDeclaration>,List<ClassDeclaration>> p = CUP$InterfaceParser$stack.peek().<Pair<List<FunctionDeclaration>,List<ClassDeclaration>>> value();
                 p.part1().add(fd); RESULT = p; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("interface_body",14, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 30: // interface_body ::= class_declaration interface_body 
            {
                Pair<List<FunctionDeclaration>,List<ClassDeclaration>> RESULT = null;
                int cleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int cright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                ClassDeclaration c = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<ClassDeclaration> value();
                int pleft = CUP$InterfaceParser$stack.peek().left;
                int pright = CUP$InterfaceParser$stack.peek().right;
                Pair<List<FunctionDeclaration>,List<ClassDeclaration>> p = CUP$InterfaceParser$stack.peek().<Pair<List<FunctionDeclaration>,List<ClassDeclaration>>> value();
                 p.part2().add(c); RESULT = p; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("interface_body",14, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 31: // interface_body ::= empty 
            {
                Pair<List<FunctionDeclaration>,List<ClassDeclaration>> RESULT = null;
                 Pair<List<FunctionDeclaration>, List<ClassDeclaration>> body = new Pair<>(new LinkedList<>(), new LinkedList<>()); RESULT = body; 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("interface_body",14, CUP$InterfaceParser$stack.peek(), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /*. . . . . . . . . . . . . . . . . . . .*/
        case 32: // interface ::= use_block interface_body 
            {
                Interface RESULT = null;
                int uleft = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).left;
                int uright = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).right;
                List<UseStatement> u = CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1).<List<UseStatement>> value();
                int ibleft = CUP$InterfaceParser$stack.peek().left;
                int ibright = CUP$InterfaceParser$stack.peek().right;
                Pair<List<FunctionDeclaration>,List<ClassDeclaration>> ib = CUP$InterfaceParser$stack.peek().<Pair<List<FunctionDeclaration>,List<ClassDeclaration>>> value();
                 RESULT = new Interface(u, ib.part1(), ib.part2()); 
                CUP$InterfaceParser$result = parser.getSymbolFactory().newSymbol("interface",15, CUP$InterfaceParser$stack.elementAt(CUP$InterfaceParser$top-1), CUP$InterfaceParser$stack.peek(), RESULT);
            }
            return CUP$InterfaceParser$result;

        /* . . . . . .*/
        default:
            throw new Exception(
                  "Invalid action number " + CUP$InterfaceParser$act_num + " found in internal parse table");

        }
    } /* end of method */

    /** Method splitting the generated action code into several parts. */
    public final java_cup.runtime.Symbol CUP$InterfaceParser$do_action(
            int                        CUP$InterfaceParser$act_num,
            java_cup.runtime.lr_parser CUP$InterfaceParser$parser,
            java.util.Stack<java_cup.runtime.Symbol> CUP$InterfaceParser$stack,
            int                        CUP$InterfaceParser$top)
            throws java.lang.Exception {
            return CUP$InterfaceParser$do_action_part00000000(
                           CUP$InterfaceParser$act_num,
                           CUP$InterfaceParser$parser,
                           CUP$InterfaceParser$stack,
                           CUP$InterfaceParser$top);
    }
}

}
