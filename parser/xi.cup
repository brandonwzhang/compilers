package com.bwz6jk2227esl89ahj34;
import com.AST.*;
import edu.cornell.cs.cs4120.util.CodeWriterSExpPrinter;
import java_cup.runtime.Symbol;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.util.*;
import java.util.AbstractMap.*;

class Parser;

parser code {:

    public static void parseFile(String sourcePath,
                             String diagnosticPath,
                             String[] files) {
        try {
            for (String file : files) {
                if (!file.contains(".xi")) {
                    System.out.println(file + "is not a .xi file. " +
                            "This file will not be parsed.");
                    continue;
                }

                FileReader reader = new FileReader(sourcePath + file);
                Lexer lexer = new Lexer(reader);
                Parser parser = new Parser(lexer);

                String output = file.replace(".xi", ".parsed");
                String writeFile = diagnosticPath + output;
                Util.makePath(writeFile.substring(0, writeFile.lastIndexOf('/') + 1));

                Symbol result = parser.parse();

                if (parser.hasSyntaxError) {
                    // handle syntax error, output to file
                    parser.hasSyntaxError = false;
                    Util.writeAndClose(writeFile, new
                            ArrayList<String>(Arrays.asList(parser.syntaxErrMessage)));

                    parser.syntaxErrMessage = "";
                    continue;
                }

                FileOutputStream fos = new FileOutputStream(
                        new File(writeFile));
                CodeWriterSExpPrinter printer =
                        new CodeWriterSExpPrinter(fos);
                NodeVisitor visitor = new PrintVisitor(printer);

                ((Program)(result.value)).accept(visitor);
                printer.flush();
            }
        } catch(Exception e) {
            e.printStackTrace();
        }
    }

    public boolean hasSyntaxError = false;
    public String syntaxErrMessage = "";
    
    public void syntax_error(java_cup.runtime.Symbol cur_token){
        hasSyntaxError = true;
        syntaxErrMessage = cur_token.left + ":" + cur_token.right + 
          " error: Unexpected token " + Util.symbolTranslation.get(cur_token.sym);
        if (cur_token.value != null) {
            syntaxErrMessage += " " + cur_token.value;
        }
        done_parsing();
    }
:}

terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Character CHARACTER_LITERAL;
terminal String INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, BREAK, RETURN, USE, LENGTH, PLUS, MINUS, TIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, HIGH_MULT;

nonterminal Program program;

nonterminal empty;
nonterminal List<UseStatement> use_block;

nonterminal Expression A;
nonterminal Expression B;
nonterminal Expression C;
nonterminal Expression D;
nonterminal Expression E;
nonterminal Expression F;
nonterminal Expression G;
nonterminal Expression H;
nonterminal Expression I;

nonterminal BooleanLiteral boolean_literal; 
nonterminal ArrayLiteral array_literal;

nonterminal Expression expression; 
nonterminal List<Expression> expression_list; 
nonterminal List<Expression> expression_list_trailing_comma; 

nonterminal PrimitiveType primitive_type;
nonterminal VariableType var_type;
nonterminal SimpleEntry<List<Expression>, Integer> array_size_type;
nonterminal Integer array_no_size_type;

nonterminal TypedDeclaration typed_declaration; 
nonterminal FunctionCall function_call;
nonterminal ArrayIndex assignment_lhs_array_brackets;
nonterminal Expression assignment_lhs_array;
nonterminal Assignable assignment_lhs;
nonterminal Assignable declaration_assignment_lhs;
nonterminal List<Assignable> multiple_assignment_lhs;
nonterminal Assignment assignment; 

nonterminal IfStatement if_statement;  
nonterminal WhileStatement while_statement;
nonterminal ReturnStatement return_statement;   
nonterminal Block block; 
nonterminal BlockList block_list; 
nonterminal Statement statement;
nonterminal Statement statement_no_semicolon;

nonterminal List<VariableType> function_declaration_return_types; 
nonterminal SimpleEntry<Identifier, VariableType> function_declaration_argument_single; 
nonterminal List<SimpleEntry<Identifier, VariableType>> function_declaration_argument_list;
nonterminal List<SimpleEntry<Identifier, VariableType>> function_declaration_argument;

nonterminal FunctionDeclaration function_declaration;
nonterminal List<FunctionDeclaration> function_declaration_list;
nonterminal FunctionBlock function_block; 
nonterminal ProcedureBlock procedure_block;

nonterminal ProcedureCall procedure_call;

precedence nonassoc ELSE; 
precedence nonassoc SEMICOLON;

start with program;

empty ::= ;

boolean_literal ::= TRUE  {: RESULT = new BooleanLiteral(true); RESULT.setLocation(parser.cur_token); :}
          | FALSE       {: RESULT = new BooleanLiteral(false); RESULT.setLocation(parser.cur_token); :}
          ;  

A ::= B:b {: RESULT = b; RESULT.setLocation(parser.cur_token); :}
    | A:a OR B:b {: RESULT = new Binary(BinaryOperator.OR, a,b); RESULT.setLocation(parser.cur_token); :}
    ;

B ::= C:c {: RESULT = c; RESULT.setLocation(parser.cur_token); :}
    | B:b AND C:c {: RESULT = new Binary(BinaryOperator.AND, b,c); RESULT.setLocation(parser.cur_token); :}
    ;

C ::= D:d {: RESULT = d; RESULT.setLocation(parser.cur_token); :}
    | C:c EQUAL D:d {: RESULT = new Binary(BinaryOperator.EQUAL, c,d); RESULT.setLocation(parser.cur_token); :}
    | C:c NOT_EQUAL D:d  {: RESULT = new Binary(BinaryOperator.NOT_EQUAL,c,d); RESULT.setLocation(parser.cur_token); :}
    ;

D ::= E:e {: RESULT = e; RESULT.setLocation(parser.cur_token); :}
    | D:d LT E:e {: RESULT = new Binary(BinaryOperator.LT, d,e); RESULT.setLocation(parser.cur_token); :}
    | D:d LEQ E:e {: RESULT = new Binary(BinaryOperator.LEQ, d,e); RESULT.setLocation(parser.cur_token); :}
    | D:d GT E:e {: RESULT = new Binary(BinaryOperator.GT, d,e); RESULT.setLocation(parser.cur_token); :}
    | D:d GEQ E:e  {: RESULT = new Binary(BinaryOperator.GEQ, d,e); RESULT.setLocation(parser.cur_token); :}
    ;

E ::= F:f {: RESULT = f; RESULT.setLocation(parser.cur_token); :}
    | E:e PLUS F:f {: RESULT = new Binary(BinaryOperator.PLUS, e,f); RESULT.setLocation(parser.cur_token); :}
    | E:e MINUS F:f {: RESULT = new Binary(BinaryOperator.MINUS,e,f); RESULT.setLocation(parser.cur_token); :}
    ; 

F ::= G:g {: RESULT = g; RESULT.setLocation(parser.cur_token); :}
    | F:f TIMES G:g {: RESULT = new Binary(BinaryOperator.TIMES, f,g); RESULT.setLocation(parser.cur_token); :}
    | F:f HIGH_MULT G:g  {: RESULT = new Binary(BinaryOperator.HIGH_MULT, f,g); RESULT.setLocation(parser.cur_token); :}
    | F:f DIVIDE G:g  {: RESULT = new Binary(BinaryOperator.DIVIDE, f,g); RESULT.setLocation(parser.cur_token); :}
    | F:f MODULO G:g  {: RESULT = new Binary(BinaryOperator.MODULO, f,g); RESULT.setLocation(parser.cur_token); :}
    ;  

G ::= H:h {: RESULT = h; RESULT.setLocation(parser.cur_token); :}
    | NOT H:h {: RESULT = new Unary(UnaryOperator.NOT, h); RESULT.setLocation(parser.cur_token); :}
    | MINUS H:h {: RESULT = new Unary(UnaryOperator.MINUS, h); RESULT.setLocation(parser.cur_token); :}
    ;

H ::= I:i {: RESULT = i; RESULT.setLocation(parser.cur_token); :}
    | function_call:fc {: RESULT = fc; RESULT.setLocation(parser.cur_token); :}
    | H:h OPEN_BRACKET A:a CLOSE_BRACKET {: RESULT = new ArrayIndex(h,a); RESULT.setLocation(parser.cur_token); :}
    ;

I ::= boolean_literal:b {: RESULT = b; RESULT.setLocation(parser.cur_token); :}
    | INTEGER_LITERAL:i {: RESULT = new IntegerLiteral(i); RESULT.setLocation(parser.cur_token); :}
    | OPEN_PAREN A:a CLOSE_PAREN {: RESULT = a; RESULT.setLocation(parser.cur_token); :}
    | IDENTIFIER: i {: RESULT = new Identifier(i); RESULT.setLocation(parser.cur_token); :}
    | STRING_LITERAL:s {: RESULT = new StringLiteral(s); RESULT.setLocation(parser.cur_token); :} 
    | CHARACTER_LITERAL:c {: RESULT = new CharacterLiteral(c); RESULT.setLocation(parser.cur_token); :}
    | array_literal:al {: RESULT = al; RESULT.setLocation(parser.cur_token); :}
    ;


expression ::= A:a {: RESULT = a; RESULT.setLocation(parser.cur_token); :}
             ; 
 
expression_list ::= expression:e COMMA expression_list:lst {: lst.add(0, e); RESULT = lst; :} 
                  | expression:e {: List<Expression> lst = new LinkedList<>(); lst.add(0, e); RESULT = lst; :}
                  ;

expression_list_trailing_comma ::= expression:e COMMA expression_list_trailing_comma:lst {: lst.add(0, e); RESULT = lst; :} 
                                 | expression:e COMMA {: List<Expression> lst = new LinkedList<>(); lst.add(0, e); RESULT = lst; :}
                                 ;
 
array_literal ::= OPEN_BRACE expression_list:lst CLOSE_BRACE {: RESULT = new ArrayLiteral(lst); RESULT.setLocation(parser.cur_token); :}
                |  OPEN_BRACE expression_list_trailing_comma:lst CLOSE_BRACE {: RESULT = new ArrayLiteral(lst); RESULT.setLocation(parser.cur_token); :}
                ;

primitive_type ::= INT {: RESULT = PrimitiveType.INT; :}
                 | BOOL {: RESULT = PrimitiveType.BOOL; :}
                 ; 

array_size_type ::= OPEN_BRACKET expression:e CLOSE_BRACKET array_size_type:ast {: ast.getKey().add(0, e); RESULT = ast; :}
                  | array_no_size_type:anst {: RESULT = new SimpleEntry<List<Expression>, Integer>(new LinkedList<>(), anst); :}
                  ;

array_no_size_type ::= OPEN_BRACKET CLOSE_BRACKET array_no_size_type:anst {: RESULT = anst + 1; :}
                     | empty {: RESULT = 0; :} 
                     ;

var_type ::= primitive_type:pt array_no_size_type: anst {: RESULT = new VariableType(pt, anst); :}
       ;
       

typed_declaration ::= IDENTIFIER:id COLON primitive_type:t array_size_type:ast {: RESULT = new TypedDeclaration(new Identifier(id), new VariableType(t, ast.getKey().size() + ast.getValue()), ast.getKey()); RESULT.setLocation(parser.cur_token); :} //x:int
                    ;

function_call ::= IDENTIFIER:id OPEN_PAREN expression_list:lst CLOSE_PAREN {: RESULT = new FunctionCall(new Identifier(id), lst); RESULT.setLocation(parser.cur_token); :}//f(x,y,z,...) 
                | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN {: RESULT = new FunctionCall(new Identifier(id), new LinkedList<Expression>()); RESULT.setLocation(parser.cur_token); :} // f()
                | LENGTH OPEN_PAREN expression:e CLOSE_PAREN {: List<Expression> lst = new LinkedList<>(); lst.add(0, e); RESULT = new FunctionCall(new Identifier("length"), lst); RESULT.setLocation(parser.cur_token); :}
                ;


assignment_lhs_array_brackets ::= assignment_lhs_array:a OPEN_BRACKET expression:e CLOSE_BRACKET {: RESULT = new ArrayIndex(a,e); RESULT.setLocation(parser.cur_token); :}
                                ;

assignment_lhs_array ::= function_call:fc {: RESULT = fc; RESULT.setLocation(parser.cur_token); :}
                       | STRING_LITERAL:s {: RESULT = new StringLiteral(s); RESULT.setLocation(parser.cur_token); :} 
                       | IDENTIFIER:i {: RESULT = new Identifier(i); RESULT.setLocation(parser.cur_token); :}
                       | assignment_lhs_array_brackets:a {: RESULT = a; RESULT.setLocation(parser.cur_token); :}
                       ;


assignment_lhs ::= IDENTIFIER:id {: RESULT = new Identifier(id); :}
                 | assignment_lhs_array_brackets:a {: RESULT = a; :}
                 | typed_declaration:td {: RESULT = td; :}
                 | function_call:fc {: RESULT = fc; :}
                 | UNDERSCORE {: RESULT = new Underscore(); :}
                 ;

declaration_assignment_lhs ::= typed_declaration:td {: RESULT = td; :}
                             | UNDERSCORE {: RESULT = new Underscore(); :}
                             ;
multiple_assignment_lhs ::= declaration_assignment_lhs:dl COMMA multiple_assignment_lhs:dll {: dll.add(0, dl); RESULT = dll; :}
                          | declaration_assignment_lhs:dl1 COMMA declaration_assignment_lhs:dl2 {: LinkedList<Assignable> lst = new LinkedList<Assignable>(Arrays.asList(dl2)); lst.add(0, dl1); RESULT = lst; :}
                          ;

assignment ::= assignment_lhs:al GETS expression:e {: List<Assignable> lst = new LinkedList<>(); lst.add(0, al); RESULT = new Assignment(lst, e); :}// x = expression
             | multiple_assignment_lhs:all GETS function_call:fc {: RESULT = new Assignment(all, fc); :}
             ;

if_statement ::= IF OPEN_PAREN expression:e CLOSE_PAREN block:b {: RESULT = new IfStatement(e, b, Optional.empty()); :}
               | IF OPEN_PAREN expression:e CLOSE_PAREN block:b1 ELSE block:b2 {: RESULT = new IfStatement(e, b1, Optional.of(b2)); :}
               ;

while_statement ::= WHILE OPEN_PAREN expression:e CLOSE_PAREN block:b {: RESULT = new WhileStatement(e,b); :}
                  ;

return_statement ::= RETURN expression_list:lst {: RESULT = new ReturnStatement(lst); :}
                   ;

statement_no_semicolon ::= if_statement:s {: RESULT = s; :} 
                         | while_statement:s {: RESULT = s; :}
                         | procedure_call:pc {: RESULT = pc; :}
                         | typed_declaration:td {: RESULT = td; :}
                         | assignment:a {: RESULT = a; :}
                         ; 

//this should be okay since semicolon doesn't actually matter
statement ::= statement_no_semicolon:s {: RESULT = s; :} 
            | statement_no_semicolon:s SEMICOLON {: RESULT = s; :} 
            ;

function_block ::= OPEN_BRACE block_list:bl return_statement:r CLOSE_BRACE {: RESULT = new FunctionBlock(bl, r); :}
                 | OPEN_BRACE block_list:bl return_statement:r SEMICOLON CLOSE_BRACE {: RESULT = new FunctionBlock(bl,r); :}
                 ;

block ::= OPEN_BRACE block_list:bl CLOSE_BRACE  {: RESULT = bl; :}
        | function_block:fb {: RESULT = fb; :}
        | statement:s {: RESULT = s; :}
        ;

block_list ::= block:b block_list:bl {: bl.getBlockList().add(0, b); RESULT = bl; :}
             | empty  {: RESULT = new BlockList(new LinkedList<Block>()); :}
             ;

function_declaration_return_types ::= var_type:t COMMA function_declaration_return_types:lst {: lst.add(0,t); RESULT = lst; :} 
       | var_type:t  {: List<VariableType> lst = new LinkedList<>(); lst.add(0, t); RESULT = lst; :}
       ; 

function_declaration_argument_single ::= IDENTIFIER:i COLON var_type:t {: RESULT = new SimpleEntry<Identifier, VariableType>(new Identifier(i), t); :}
                                       ;

function_declaration_argument_list ::= function_declaration_argument_single:fdas COMMA function_declaration_argument_list:lst {: lst.add(0, fdas); RESULT = lst; :}
                                     | function_declaration_argument_single:fdas {: List<SimpleEntry<Identifier, VariableType>> lst = new LinkedList<>(); lst.add(0, fdas); RESULT = lst; :}
                                     ;

function_declaration_argument ::= function_declaration_argument_list:lst {: RESULT = lst; :}
                                | empty {: RESULT = new LinkedList<>(); :}
                                ;
                
function_declaration ::= IDENTIFIER:id OPEN_PAREN function_declaration_argument:argPairs CLOSE_PAREN COLON function_declaration_return_types:t function_block:fb {: List<Identifier> args = new LinkedList<>(); List<VariableType> argTypes = new LinkedList<>(); for (SimpleEntry<Identifier, VariableType> se : argPairs) { args.add(se.getKey()); argTypes.add(se.getValue()); } RESULT = new FunctionDeclaration(new Identifier(id), new FunctionType(argTypes, t), args, fb); :}
                       | IDENTIFIER:id OPEN_PAREN function_declaration_argument:argPairs CLOSE_PAREN procedure_block:fb {: List<Identifier> args = new LinkedList<>(); List<VariableType> argTypes = new LinkedList<>(); for (SimpleEntry<Identifier, VariableType> se : argPairs) { args.add(se.getKey()); argTypes.add(se.getValue()); } RESULT = new FunctionDeclaration(new Identifier(id), new FunctionType(argTypes, new LinkedList<>()), args, fb); :}
                       ;

function_declaration_list ::= function_declaration:fd function_declaration_list:lst {: lst.add(0, fd); RESULT = lst; :}
                            | empty {: RESULT = new LinkedList<FunctionDeclaration>(); :}
                            ;
                
procedure_block ::=  OPEN_BRACE block_list:b CLOSE_BRACE {: RESULT = new ProcedureBlock(b); :}
                  | OPEN_BRACE block_list:b RETURN CLOSE_BRACE {: RESULT = new ProcedureBlock(b); :}
                  | OPEN_BRACE block_list:b RETURN SEMICOLON CLOSE_BRACE {: RESULT = new ProcedureBlock(b); :}
                  ;
                 
procedure_call ::= IDENTIFIER:id OPEN_PAREN expression_list:elist CLOSE_PAREN {: RESULT = new ProcedureCall(new Identifier(id), elist); :} //f(x,y,z,...) 
                 | IDENTIFIER:id OPEN_PAREN CLOSE_PAREN {: RESULT = new ProcedureCall(new Identifier(id), new LinkedList<Expression>()); :}// f()
                 ;

use_block ::= USE IDENTIFIER:id use_block:u {: u.add(0, new UseStatement(new Identifier(id))); RESULT = u; :} 
            | empty   {: RESULT = new LinkedList<UseStatement>(); :}
            ;
      

program ::= use_block:u function_declaration_list:l   {: RESULT = new Program(u,l); :}
          | error
          ; 
