package com.bwz6jk2227esl89ahj34.ast.parse;

import com.bwz6jk2227esl89ahj34.ast.*;
import com.bwz6jk2227esl89ahj34.ast.type.FunctionType;
import com.bwz6jk2227esl89ahj34.ast.type.IntType;
import com.bwz6jk2227esl89ahj34.ast.type.BoolType;
import com.bwz6jk2227esl89ahj34.ast.type.PrimitiveType;
import com.bwz6jk2227esl89ahj34.ast.type.ArrayType;
import com.bwz6jk2227esl89ahj34.ast.type.VariableType;
import com.bwz6jk2227esl89ahj34.ast.type.VariableTypeList;
import com.bwz6jk2227esl89ahj34.util.Util;
import com.bwz6jk2227esl89ahj34.util.prettyprint.Pair;

import java.util.AbstractMap.SimpleEntry;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;

class Parser;

parser code {:

    public boolean hasSyntaxError = false;
    public String syntaxErrMessage = "";

    public void syntax_error(java_cup.runtime.Symbol cur_token){
        hasSyntaxError = true;
        syntaxErrMessage = cur_token.left + ":" + cur_token.right +
          " error: Unexpected token " + Util.symbolTranslation.get(cur_token.sym);
        if (cur_token.value != null) {
            syntaxErrMessage += " " + cur_token.value;
        }
        done_parsing();
    }
:}

terminal String IDENTIFIER;
terminal String STRING_LITERAL;
terminal Character CHARACTER_LITERAL;
terminal String INTEGER_LITERAL;
terminal TRUE, FALSE;
terminal INT, BOOL;

terminal IF, ELSE, WHILE, BREAK, RETURN, USE, PLUS, MINUS, TIMES,
  DIVIDE, MODULO, NOT, LT, LEQ, GT, GEQ, AND, OR, EQUAL, NOT_EQUAL, GETS,
  OPEN_BRACKET, CLOSE_BRACKET, OPEN_PAREN, CLOSE_PAREN, OPEN_BRACE, CLOSE_BRACE,
  COLON, COMMA, SEMICOLON, UNDERSCORE, HIGH_MULT, NEGATIVE_INT_BOUND, LENGTH, CLASS, EXTENDS, NEW, PERIOD;

nonterminal Program program;

nonterminal empty;
nonterminal Identifier identifier;
nonterminal List<UseStatement> use_block;

nonterminal Expression minus_list;
nonterminal Expression not_list;

nonterminal Expression A;
nonterminal Expression B;
nonterminal Expression C;
nonterminal Expression D;
nonterminal Expression E;
nonterminal Expression F;
nonterminal Expression G;
nonterminal Expression H;
nonterminal Expression I;

nonterminal BooleanLiteral boolean_literal;
nonterminal ArrayLiteral array_literal;

nonterminal Expression expression;
nonterminal List<Expression> expression_list;
nonterminal List<Expression> expression_list_trailing_comma;

nonterminal PrimitiveType primitive_type;
nonterminal VariableType var_type;
nonterminal SimpleEntry<List<Expression>, Integer> array_size_type;
nonterminal Integer array_no_size_type;

nonterminal TypedDeclaration typed_declaration;
nonterminal TypedDeclaration typed_declaration_no_size;
nonterminal FunctionCall function_call;
nonterminal ArrayIndex assignment_lhs_array_brackets;
nonterminal Expression assignment_lhs_array;
nonterminal Assignable assignment_lhs;
nonterminal Assignable declaration_assignment_lhs;
nonterminal List<Assignable> multiple_assignment_lhs;
nonterminal Assignment assignment;

nonterminal IfStatement if_statement;
nonterminal WhileStatement while_statement;
nonterminal ReturnStatement return_statement;
nonterminal Block block;
nonterminal BlockList block_list;
nonterminal BlockList block_scope;
nonterminal Statement statement;
nonterminal Statement statement_no_semicolon;

nonterminal List<VariableType> function_declaration_return_types;
nonterminal SimpleEntry<Identifier, VariableType> function_declaration_argument_single;
nonterminal List<SimpleEntry<Identifier, VariableType>> function_declaration_argument_list;
nonterminal List<SimpleEntry<Identifier, VariableType>> function_declaration_argument;

nonterminal FunctionDeclaration function_declaration;

nonterminal ProcedureCall procedure_call;
nonterminal List<TypedDeclaration> typed_declaration_list; 
nonterminal List<TypedDeclaration> field; 
nonterminal Pair<List<TypedDeclaration>, List<FunctionDeclaration>> class_declaration_body;
nonterminal ClassDeclaration class_declaration; 
nonterminal Pair<List<FunctionDeclaration>, List<ClassDeclaration>> program_body;

precedence nonassoc ELSE;
precedence nonassoc SEMICOLON;

start with program;

empty ::= ;

identifier ::= IDENTIFIER:id {: RESULT = new Identifier(id); RESULT.setLocation(parser.stack.peek()); :}
             ;

minus_list ::= MINUS minus_list:m {: RESULT = new Unary(UnaryOperator.MINUS, m); RESULT.setLocation(m); :}
             | MINUS NEGATIVE_INT_BOUND:i {: RESULT = new Unary(UnaryOperator.MINUS, new IntegerLiteral("9223372036854775808")); RESULT.setLocation(parser.stack.peek()); :}
             | MINUS H:h {: RESULT = new Unary(UnaryOperator.MINUS, h); RESULT.setLocation(h); :}
             ;

not_list ::= NOT not_list:n {: RESULT = new Unary(UnaryOperator.NOT, n); RESULT.setLocation(n); :}
           |NOT H:h {: RESULT = new Unary(UnaryOperator.NOT, h); RESULT.setLocation(h); :}
           ;

boolean_literal ::= TRUE  {: RESULT = new BooleanLiteral(true); RESULT.setLocation(parser.stack.peek()); :}
          | FALSE       {: RESULT = new BooleanLiteral(false); RESULT.setLocation(parser.stack.peek()); :}
          ;

A ::= B:b {: RESULT = b; RESULT.setLocation(b); :}
    | A:a OR B:b {: RESULT = new Binary(BinaryOperator.OR, a,b); RESULT.setLocation(a); :}
    ;

B ::= C:c {: RESULT = c; RESULT.setLocation(c); :}
    | B:b AND C:c {: RESULT = new Binary(BinaryOperator.AND, b,c); RESULT.setLocation(b); :}
    ;

C ::= D:d {: RESULT = d; RESULT.setLocation(d); :}
    | C:c EQUAL D:d {: RESULT = new Binary(BinaryOperator.EQUAL, c,d); RESULT.setLocation(c); :}
    | C:c NOT_EQUAL D:d  {: RESULT = new Binary(BinaryOperator.NOT_EQUAL,c,d); RESULT.setLocation(c); :}
    ;

D ::= E:e {: RESULT = e; RESULT.setLocation(e); :}
    | D:d LT E:e {: RESULT = new Binary(BinaryOperator.LT, d,e); RESULT.setLocation(d); :}
    | D:d LEQ E:e {: RESULT = new Binary(BinaryOperator.LEQ, d,e); RESULT.setLocation(d); :}
    | D:d GT E:e {: RESULT = new Binary(BinaryOperator.GT, d,e); RESULT.setLocation(d); :}
    | D:d GEQ E:e  {: RESULT = new Binary(BinaryOperator.GEQ, d,e); RESULT.setLocation(d); :}
    ;

E ::= F:f {: RESULT = f; RESULT.setLocation(parser.cur_token); :}
    | E:e PLUS F:f {: RESULT = new Binary(BinaryOperator.PLUS, e,f); RESULT.setLocation(e); :}
    | E:e MINUS F:f {: RESULT = new Binary(BinaryOperator.MINUS,e,f); RESULT.setLocation(e); :}
    ;

F ::= G:g {: RESULT = g; RESULT.setLocation(g); :}
    | F:f TIMES G:g {: RESULT = new Binary(BinaryOperator.TIMES, f,g); RESULT.setLocation(f); :}
    | F:f HIGH_MULT G:g  {: RESULT = new Binary(BinaryOperator.HIGH_MULT, f,g); RESULT.setLocation(f); :}
    | F:f DIVIDE G:g  {: RESULT = new Binary(BinaryOperator.DIVIDE, f,g); RESULT.setLocation(f); :}
    | F:f MODULO G:g  {: RESULT = new Binary(BinaryOperator.MODULO, f,g); RESULT.setLocation(f); :}
    ;

G ::= H:h {: RESULT = h; RESULT.setLocation(h); :}
    | not_list:n {: RESULT = n; RESULT.setLocation(n); :}
    | minus_list:m {: RESULT = m; RESULT.setLocation(m); :}
    ;

H ::= I:i {: RESULT = i; RESULT.setLocation(i); :}
    | function_call:fc {: RESULT = fc; RESULT.setLocation(fc); :}
    | H:h OPEN_BRACKET A:a CLOSE_BRACKET {: RESULT = new ArrayIndex(h,a); RESULT.setLocation(h); :}
    ;

I ::= boolean_literal:b {: RESULT = b; RESULT.setLocation(b); :}
    | INTEGER_LITERAL:i {: RESULT = new IntegerLiteral(i); RESULT.setLocation(parser.stack.peek()); :}
    | OPEN_PAREN A:a CLOSE_PAREN {: RESULT = a; RESULT.setLocation(parser.cur_token); :}
    | identifier: i {: RESULT = i; RESULT.setLocation(parser.cur_token); :}
    | STRING_LITERAL:s {: RESULT = new StringLiteral(s); RESULT.setLocation(parser.stack.peek()); :}
    | CHARACTER_LITERAL:c {: RESULT = new CharacterLiteral(c); RESULT.setLocation(parser.stack.peek()); :}
    | array_literal:al {: RESULT = al; RESULT.setLocation(al); :}
    | NEW identifier:i {: RESULT = new ObjectInstantiation(i); :}
    ;


expression ::= A:a {: RESULT = a; RESULT.setLocation(parser.cur_token); :}
             ;

expression_list ::= expression:e COMMA expression_list:lst {: lst.add(0, e); RESULT = lst; :}
                  | expression:e {: List<Expression> lst = new LinkedList<>(); lst.add(0, e); RESULT = lst; :}
                  ;

expression_list_trailing_comma ::= expression:e COMMA expression_list_trailing_comma:lst {: lst.add(0, e); RESULT = lst; :}
                                 | expression:e COMMA {: List<Expression> lst = new LinkedList<>(); lst.add(0, e); RESULT = lst; :}
                                 ;

array_literal ::= OPEN_BRACE expression_list:lst CLOSE_BRACE {: RESULT = new ArrayLiteral(lst); RESULT.setLocation(parser.cur_token); :}
                |  OPEN_BRACE expression_list_trailing_comma:lst CLOSE_BRACE {: RESULT = new ArrayLiteral(lst); RESULT.setLocation(parser.cur_token); :}
                | OPEN_BRACE CLOSE_BRACE {: RESULT = new ArrayLiteral(new LinkedList<>()); RESULT.setLocation(parser.cur_token); :}
                ;

primitive_type ::= INT {: RESULT = new IntType(); :}
                 | BOOL {: RESULT = new BoolType(); :}
                 ;

array_size_type ::= OPEN_BRACKET expression:e CLOSE_BRACKET array_size_type:ast {: ast.getKey().add(0, e); RESULT = ast; :}
                  | array_no_size_type:anst {: RESULT = new SimpleEntry<List<Expression>, Integer>(new LinkedList<>(), anst); :}
                  ;

array_no_size_type ::= OPEN_BRACKET CLOSE_BRACKET array_no_size_type:anst {: RESULT = anst + 1; :}
                     | empty {: RESULT = 0; :}
                     ;

var_type ::= primitive_type:pt array_no_size_type: anst {: RESULT = VariableType.construct(pt, anst); :}
       ;


typed_declaration_no_size ::= identifier:id COLON primitive_type:t array_no_size_type:ast {: RESULT = new TypedDeclaration(id, VariableType.construct(t, ast), new LinkedList<Expression>()); RESULT.setLocation(parser.cur_token); :} //x:int
                    ;

typed_declaration ::= identifier:id COLON primitive_type:t array_size_type:ast {: RESULT = new TypedDeclaration(id, VariableType.construct(t, ast.getKey().size() + ast.getValue()), ast.getKey()); RESULT.setLocation(parser.cur_token); :} //x:int
                    ;

function_call ::= identifier:id OPEN_PAREN expression_list:lst CLOSE_PAREN {: RESULT = new FunctionCall(id, lst); RESULT.setLocation(id); :}//f(x,y,z,...)
                | identifier:id OPEN_PAREN CLOSE_PAREN {: RESULT = new FunctionCall(id, new LinkedList<Expression>()); RESULT.setLocation(id); :} // f()
                | LENGTH:id OPEN_PAREN expression_list:lst CLOSE_PAREN {: RESULT = new FunctionCall(new Identifier("length"), lst); RESULT.setLocation(parser.cur_token); :}
                ;

assignment_lhs_array_brackets ::= assignment_lhs_array:a OPEN_BRACKET expression:e CLOSE_BRACKET {: RESULT = new ArrayIndex(a,e); RESULT.setLocation(a); :}
                                ;

assignment_lhs_array ::= function_call:fc {: RESULT = fc; RESULT.setLocation(fc); :}
                       | STRING_LITERAL:s {: RESULT = new StringLiteral(s); RESULT.setLocation(parser.stack.peek()); :}
                       | identifier:i {: RESULT = i; RESULT.setLocation(i); :}
                       | assignment_lhs_array_brackets:a {: RESULT = a; RESULT.setLocation(a); :}
                       ;


assignment_lhs ::= identifier:id {: RESULT = id; RESULT.setLocation(parser.cur_token); :}
                 | assignment_lhs_array_brackets:a {: RESULT = a; RESULT.setLocation(parser.cur_token); :}
                 | typed_declaration_no_size:td {: RESULT = td; RESULT.setLocation(parser.cur_token); :}
                 | function_call:fc {: RESULT = fc; RESULT.setLocation(parser.cur_token); :}
                 | UNDERSCORE {: RESULT = new Underscore(); RESULT.setLocation(parser.cur_token); :}
                 ;

declaration_assignment_lhs ::= typed_declaration_no_size:td {: RESULT = td; RESULT.setLocation(parser.cur_token); :}
                             | UNDERSCORE {: RESULT = new Underscore(); RESULT.setLocation(parser.cur_token); :}
                             ;
multiple_assignment_lhs ::= declaration_assignment_lhs:dl COMMA multiple_assignment_lhs:dll {: dll.add(0, dl); RESULT = dll; :}
                          | declaration_assignment_lhs:dl1 COMMA declaration_assignment_lhs:dl2 {: LinkedList<Assignable> lst = new LinkedList<Assignable>(Arrays.asList(dl2)); lst.add(0, dl1); RESULT = lst; :}
                          ;

assignment ::= assignment_lhs:al GETS expression:e {: List<Assignable> lst = new LinkedList<>(); lst.add(0, al); RESULT = new Assignment(lst, e); RESULT.setLocation(parser.cur_token); :}// x = expression
             | multiple_assignment_lhs:all GETS function_call:fc {: RESULT = new Assignment(all, fc); RESULT.setLocation(parser.cur_token); :}
             ;

if_statement ::= IF OPEN_PAREN expression:e CLOSE_PAREN block:b {: RESULT = new IfStatement(e, b, Optional.empty()); RESULT.setLocation(e); :}
               | IF OPEN_PAREN expression:e CLOSE_PAREN block:b1 ELSE block:b2 {: RESULT = new IfStatement(e, b1, Optional.of(b2)); RESULT.setLocation(e); :}
               ;

while_statement ::= WHILE OPEN_PAREN expression:e CLOSE_PAREN block:b {: RESULT = new WhileStatement(e,b); RESULT.setLocation(e); :}
                  ;

return_statement ::= RETURN expression_list:lst {: RESULT = new ReturnStatement(lst); RESULT.setLocation(parser.cur_token); :}
                   ;

statement_no_semicolon ::= if_statement:s {: RESULT = s; RESULT.setLocation(s); :}
                         | while_statement:s {: RESULT = s; RESULT.setLocation(s); :}
                         | procedure_call:pc {: RESULT = pc; RESULT.setLocation(pc); :}
                         | typed_declaration:td {: RESULT = td; RESULT.setLocation(td); :}
                         | assignment:a {: RESULT = a; RESULT.setLocation(a); :}
                         | return_statement:r {: RESULT = r; RESULT.setLocation(r); :}
                         ;

//this should be okay since semicolon doesn't actually matter
statement ::= statement_no_semicolon:s {: RESULT = s; RESULT.setLocation(s); :}
            | statement_no_semicolon:s SEMICOLON {: RESULT = s; RESULT.setLocation(s); :}
            ;

block ::= block_scope:bl {: RESULT = bl; RESULT.setLocation(bl); :}
        | statement:s {: RESULT = s; RESULT.setLocation(s); :}
        ;

// x,y:int 
typed_declaration_list ::= identifier:id COMMA typed_declaration:td {: List<TypedDeclaration> f = new LinkedList<>(); f.add(td); f.add(0, new TypedDeclaration(id, td.getDeclarationType(), td.getArraySizes())); RESULT = f; :}
              | identifier:id COMMA typed_declaration_list:f {: TypedDeclaration temp = f.get(f.size()-1); f.add(0, new TypedDeclaration(id, temp.getDeclarationType(), temp.getArraySizes())); RESULT = f; :} 
              ; 

block_list ::= block:b block_list:bl {: bl.getBlocks().add(0, b); RESULT = bl; RESULT.setLocation(b); :}
             | typed_declaration_list:f block_list:bl {: for(TypedDeclaration td : f) { bl.getBlocks().add(0, td); } RESULT = bl; :}
             | RETURN {: List<Block> bl = new LinkedList<>(); bl.add(0,new ReturnStatement(new LinkedList<>())); RESULT = new BlockList(bl); :}
             | empty  {: List<Block> bl = new LinkedList<>(); RESULT = new BlockList(bl); :}
             ;

block_scope ::= OPEN_BRACE block_list:bl CLOSE_BRACE {: RESULT = bl; RESULT.setLocation(bl); :}
              ;

function_declaration_return_types ::= var_type:t COMMA function_declaration_return_types:lst {: lst.add(0,t); RESULT = lst; :}
       | var_type:t  {: List<VariableType> lst = new LinkedList<>(); lst.add(0, t); RESULT = lst; :}
       ;

function_declaration_argument_single ::= identifier:i COLON var_type:t {: RESULT = new SimpleEntry<Identifier, VariableType>(i, t); :}
                                       ;

function_declaration_argument_list ::= function_declaration_argument_single:fdas COMMA function_declaration_argument_list:lst {: lst.add(0, fdas); RESULT = lst; :}
                                     | function_declaration_argument_single:fdas {: List<SimpleEntry<Identifier, VariableType>> lst = new LinkedList<>(); lst.add(0, fdas); RESULT = lst; :}
                                     ;

function_declaration_argument ::= function_declaration_argument_list:lst {: RESULT = lst; :}
                                | empty {: RESULT = new LinkedList<>(); :}
                                ;

function_declaration ::= identifier:id OPEN_PAREN function_declaration_argument:argPairs CLOSE_PAREN COLON function_declaration_return_types:t OPEN_BRACE block_list:fb CLOSE_BRACE {: List<Identifier> args = new LinkedList<>(); List<VariableType> argTypes = new LinkedList<>(); for (SimpleEntry<Identifier, VariableType> se : argPairs) { args.add(se.getKey()); argTypes.add(se.getValue()); } RESULT = new FunctionDeclaration(id, new FunctionType(argTypes, new VariableTypeList(t)), args, fb); RESULT.setLocation(id); :}
                       | identifier:id OPEN_PAREN function_declaration_argument:argPairs CLOSE_PAREN OPEN_BRACE block_list:fb CLOSE_BRACE {: List<Identifier> args = new LinkedList<>(); List<VariableType> argTypes = new LinkedList<>(); for (SimpleEntry<Identifier, VariableType> se : argPairs) { args.add(se.getKey()); argTypes.add(se.getValue()); } RESULT = new FunctionDeclaration(id, new FunctionType(argTypes, new VariableTypeList(new LinkedList<>())), args, fb); RESULT.setLocation(id); :}
                       ;

procedure_call ::= identifier:id OPEN_PAREN expression_list:elist CLOSE_PAREN {: RESULT = new ProcedureCall(id, elist); RESULT.setLocation(id); :} //f(x,y,z,...)
                 | identifier:id OPEN_PAREN CLOSE_PAREN {: RESULT = new ProcedureCall(id, new LinkedList<Expression>()); RESULT.setLocation(id); :}// f()
                 ;

use_block ::= USE identifier:id use_block:u {: u.add(0, new UseStatement(id)); RESULT = u; RESULT.get(0).setLocation(id); :}
            | USE identifier:id SEMICOLON use_block:u {: u.add(0, new UseStatement(id)); RESULT = u; RESULT.get(0).setLocation(id); :}
            | empty   {: RESULT = new LinkedList<UseStatement>(); :}
            ;

field ::= typed_declaration_list:td {: RESULT = td; :}
         | typed_declaration:td {: List<TypedDeclaration> lst = new LinkedList<>(); lst.add(td); RESULT = lst; :}
         ;

class_declaration_body ::= field:f class_declaration_body:c {: c.part1().addAll(f); RESULT = c ; :}
                       | function_declaration:f class_declaration_body:c {: c.part2().add(f); RESULT = c; :}
                       | empty {: Pair<List<TypedDeclaration>, List<FunctionDeclaration>> pair = new Pair<>(new LinkedList<>(), new LinkedList<>()); RESULT = pair; :}
                       ; 

class_declaration ::= CLASS identifier:id OPEN_BRACE class_declaration_body:body CLOSE_BRACE {: List<MethodDeclaration> methods = new LinkedList<>(); for(FunctionDeclaration fd : body.part2()) { methods.add(new MethodDeclaration(id, fd)); } RESULT = new ClassDeclaration(id, body.part1(), methods, Optional.empty()); :}
                    | CLASS identifier:id EXTENDS identifier:id2 OPEN_BRACE class_declaration_body:body CLOSE_BRACE {: List<MethodDeclaration> methods = new LinkedList<>(); for(FunctionDeclaration fd : body.part2()) { methods.add(new MethodDeclaration(id, fd)); } RESULT = new ClassDeclaration(id, body.part1(), methods, Optional.of(id2)); :}
                    ;

program_body ::= class_declaration:c program_body:p {: p.part2().add(c); RESULT = p; :}
               | function_declaration:fd program_body:p {: p.part1().add(fd); RESULT = p; :} 
               | empty {: Pair<List<FunctionDeclaration>, List<ClassDeclaration>> body = new Pair<>(new LinkedList<>(), new LinkedList<>()); RESULT = body; :}
               ; 

program ::= use_block:u program_body:b   {: RESULT = new Program(u,b.part1(), b.part2()); RESULT.setLocation(parser.cur_token); :}
          | error
          ;
